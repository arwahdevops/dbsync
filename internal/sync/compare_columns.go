// internal/sync/compare_columns.go
package sync

import (
	"fmt"
	"regexp"
	"strconv"
	"strings"

	"github.com/cockroachdb/apd/v3"
	"go.uber.org/zap"
)

// --- Fungsi Helper Ekstraksi dan Normalisasi (yang relevan untuk file ini) ---

// extractBaseTypeFromGenerated mencoba mengekstrak tipe data dasar dari definisi kolom generated.
// Contoh: "INT AS (...)" -> "INT"; "VARCHAR(255) GENERATED ALWAYS AS (...)" -> "VARCHAR(255)"
func extractBaseTypeFromGenerated(fullType string, log *zap.Logger) string {
	// Regex utama: menangkap tipe data (termasuk modifier dalam kurung dan kata kunci seperti UNSIGNED)
	// sebelum kata kunci generated seperti AS, GENERATED BY DEFAULT AS IDENTITY, GENERATED ALWAYS AS.
	// Diperbarui untuk lebih baik menangani spasi dan variasi kata kunci.
	rePrimary := regexp.MustCompile(
		`(?i)^((?:[a-zA-Z_][a-zA-Z0-9_]*(?:\s*\([^)]+\))?)(?:\s+[a-zA-Z_]+)*)\s+` + // Tipe data
			`(?:AS\s*\(|GENERATED\s+(?:BY\s+DEFAULT\s+AS\s+IDENTITY|ALWAYS\s+AS(?:LICATION)?)\s*\()`, // Kata kunci generated
	)
	matchesPrimary := rePrimary.FindStringSubmatch(fullType)
	if len(matchesPrimary) > 1 && strings.TrimSpace(matchesPrimary[1]) != "" {
		extracted := strings.TrimSpace(matchesPrimary[1])
		log.Debug("Successfully extracted base type from generated column definition via primary regex.",
			zap.String("full_type", fullType),
			zap.String("extracted_base_type", extracted))
		return extracted
	}

	// Fallback regex: untuk kasus yang lebih sederhana seperti "INT VIRTUAL", "TEXT STORED"
	// di mana ekspresi AS (...) mungkin tidak ada atau tidak ditangkap oleh regex utama.
	reFallback := regexp.MustCompile(
		`(?i)^((?:[a-zA-Z_][a-zA-Z0-9_]*(?:\s*\([^)]+\))?)(?:\s+[a-zA-Z_]+)*)\s+` + // Tipe data
			`(?:VIRTUAL|STORED|PERSISTENT|GENERATED|IDENTITY)(?:[\s(]|$)`, // Kata kunci di akhir atau diikuti spasi/kurung
	)
	matchesFallback := reFallback.FindStringSubmatch(fullType)
	if len(matchesFallback) > 1 && strings.TrimSpace(matchesFallback[1]) != "" {
		extracted := strings.TrimSpace(matchesFallback[1])
		log.Debug("Successfully extracted base type from generated column definition via fallback regex.",
			zap.String("full_type", fullType),
			zap.String("fallback_extracted_base_type", extracted))
		return extracted
	}

	log.Warn("Could not reliably extract base type from generated column definition using regex. Falling back to using the full type string. This might lead to incorrect type comparisons if the full string contains generation expressions.",
		zap.String("full_type", fullType))
	return fullType // Fallback jika semua regex gagal
}

// normalizeCollation menormalisasi nama kolasi.
func normalizeCollation(coll, dialect string) string {
	c := strings.ToLower(strings.TrimSpace(coll))
	if c == "default" || c == "" {
		return ""
	}
	// TODO: Pertimbangkan normalisasi spesifik dialek lebih lanjut jika diperlukan (misal, alias kolasi).
	return c
}

// isLargeTextOrBlob memeriksa apakah tipe yang dinormalisasi adalah tipe teks/blob besar.
func isLargeTextOrBlob(normalizedTypeName string) bool {
	return strings.Contains(normalizedTypeName, "text") ||
		strings.Contains(normalizedTypeName, "blob") ||
		normalizedTypeName == "clob" ||
		normalizedTypeName == "bytea" ||
		normalizedTypeName == "json" ||
		normalizedTypeName == "xml"
}

// stripQuotes menghapus satu lapis kutipan terluar (single, double, backtick).
func stripQuotes(s string) string {
	s = strings.TrimSpace(s)
	if len(s) >= 2 {
		first, last := s[0], s[len(s)-1]
		if (first == '\'' && last == '\'') ||
			(first == '"' && last == '"') ||
			(first == '`' && last == '`') {
			return s[1 : len(s)-1]
		}
	}
	return s
}

// isKnownDbFunction memeriksa apakah nilai default yang *sudah dinormalisasi* adalah fungsi DB umum.
func isKnownDbFunction(normalizedDefaultValue string) bool {
	switch normalizedDefaultValue {
	case "current_timestamp", "current_date", "current_time",
		"nextval", "uuid_function":
		return true
	}
	return false
}

// --- Fungsi Perbandingan Inti ---

// determineSourceTypeForComparison adalah helper untuk menentukan tipe sumber yang akan digunakan
// dalam pemanggilan `areTypesEquivalent` dan sebagai konteks untuk perbandingan default/collation.
func (s *SchemaSyncer) determineSourceTypeForComparison(src ColumnInfo, columnLogger *zap.Logger) string {
	if src.IsGenerated {
		// Untuk kolom generated, selalu ekstrak tipe dasarnya untuk perbandingan.
		baseSrcType := extractBaseTypeFromGenerated(src.Type, columnLogger)
		columnLogger.Debug("Source column is generated. Using its extracted base type for comparison logic.",
			zap.String("original_src_type_with_expr", src.Type),
			zap.String("extracted_base_src_type_for_comp", baseSrcType))
		return baseSrcType
	}

	// Untuk kolom non-generated, prioritaskan MappedType jika ada.
	if src.MappedType != "" {
		return src.MappedType
	}

	// Fallback jika MappedType kosong untuk kolom non-generated.
	// Ini menandakan masalah pada tahap mapping tipe sebelumnya.
	columnLogger.Error("Source column MappedType is empty and column is not generated. Using original source type for comparison. This might not reflect the intended cross-dialect mapping and could lead to incorrect difference detection.",
		zap.String("src_original_type", src.Type))
	return src.Type
}

// getColumnModifications mengembalikan daftar string perbedaan untuk sebuah kolom.
func (s *SchemaSyncer) getColumnModifications(src, dst ColumnInfo, log *zap.Logger) []string {
	diffs := []string{}
	columnLogger := log.With(zap.String("column", src.Name))

	// Tentukan tipe sumber yang akan digunakan untuk perbandingan atribut dan ekuivalensi.
	srcTypeForComparison := s.determineSourceTypeForComparison(src, columnLogger)

	// 1. Perbandingan Tipe Data
	if !s.areTypesEquivalent(srcTypeForComparison, dst.Type, src, dst, columnLogger) {
		diffs = append(diffs, fmt.Sprintf("type (src: %s, dst: %s)", src.Type, dst.Type))
	}

	// 2. Perbandingan Nullability
	if src.IsNullable != dst.IsNullable {
		diffs = append(diffs, fmt.Sprintf("nullability (src: %t, dst: %t)", src.IsNullable, dst.IsNullable))
	}

	// 3. Perbandingan Default Value
	// Hanya jika bukan auto_increment atau generated di kedua sisi.
	if !src.AutoIncrement && !src.IsGenerated && !dst.AutoIncrement && !dst.IsGenerated {
		srcDefValStr := ""; if src.DefaultValue.Valid { srcDefValStr = src.DefaultValue.String }
		dstDefValStr := ""; if dst.DefaultValue.Valid { dstDefValStr = dst.DefaultValue.String }

		// typeForDefaultComparison menggunakan srcTypeForComparison yang sudah ditentukan.
		if !s.areDefaultsEquivalent(srcDefValStr, dstDefValStr, srcTypeForComparison, columnLogger) {
			srcDefLog := "NULL"; if src.DefaultValue.Valid { srcDefLog = fmt.Sprintf("'%s'", src.DefaultValue.String) }
			dstDefLog := "NULL"; if dst.DefaultValue.Valid { dstDefLog = fmt.Sprintf("'%s'", dst.DefaultValue.String) }
			diffs = append(diffs, fmt.Sprintf("default (src: %s, dst: %s)", srcDefLog, dstDefLog))
		}
	}

	// 4. Perbandingan AutoIncrement Status
	if src.AutoIncrement != dst.AutoIncrement {
		diffs = append(diffs, fmt.Sprintf("auto_increment (src: %t, dst: %t)", src.AutoIncrement, dst.AutoIncrement))
		columnLogger.Warn("AutoIncrement/Identity status difference detected. Applying this change via ALTER is often complex or unsupported by dbsync.",
			zap.Bool("src_auto_inc", src.AutoIncrement), zap.Bool("dst_auto_inc", dst.AutoIncrement))
	}

	// 5. Perbandingan Generated Column Status & (opsional) Expression
	if src.IsGenerated != dst.IsGenerated {
		diffs = append(diffs, fmt.Sprintf("generated_status (src: %t, dst: %t)", src.IsGenerated, dst.IsGenerated))
		columnLogger.Warn("Generated column status difference detected. Modifying this often requires dropping and re-adding the column or is unsupported by dbsync.")
	} else if src.IsGenerated && dst.IsGenerated {
		// TODO: Pertimbangkan perbandingan ekspresi generated jika field GenerationExpression ditambahkan ke ColumnInfo dan diisi.
		columnLogger.Debug("Both columns are generated. Generation expression comparison is currently skipped by dbsync.")
	}

	// 6. Perbandingan Collation
	srcCollationStr := ""; if src.Collation.Valid { srcCollationStr = src.Collation.String }
	dstCollationStr := ""; if dst.Collation.Valid { dstCollationStr = dst.Collation.String }

	// typeForCollationCheck menggunakan srcTypeForComparison yang sudah ditentukan.
	if isStringType(normalizeTypeName(srcTypeForComparison)) && isStringType(normalizeTypeName(dst.Type)) {
		if srcCollationStr != "" || dstCollationStr != "" { // Hanya bandingkan jika salah satu memiliki kolasi eksplisit
			normSrcColl := normalizeCollation(srcCollationStr, s.srcDialect)
			normDstColl := normalizeCollation(dstCollationStr, s.dstDialect)
			if !strings.EqualFold(normSrcColl, normDstColl) {
				columnLogger.Debug("Collation difference detected.",
					zap.String("src_coll_raw", srcCollationStr), zap.String("dst_coll_raw", dstCollationStr),
					zap.String("src_coll_norm", normSrcColl), zap.String("dst_coll_norm", normDstColl))
				diffs = append(diffs, fmt.Sprintf("collation (src: %s, dst: %s)", srcCollationStr, dstCollationStr))
			}
		}
	}

	// 7. Perbandingan Comment (dianggap non-kritis, tidak menghasilkan diff untuk DDL)
	srcCommentStr := ""; if src.Comment.Valid { srcCommentStr = src.Comment.String }
	dstCommentStr := ""; if dst.Comment.Valid { dstCommentStr = dst.Comment.String }
	if srcCommentStr != dstCommentStr {
		columnLogger.Debug("Column comment difference detected (considered non-critical by dbsync for ALTER DDL generation).",
			zap.String("src_comment", srcCommentStr), zap.String("dst_comment", dstCommentStr))
	}

	if len(diffs) > 0 {
		columnLogger.Info("Column differences identified.", zap.Strings("differences", diffs))
	}
	return diffs
}

// areTypesEquivalent melakukan perbandingan tipe data yang lebih canggih.
// `srcTypeForComp` adalah tipe sumber yang sudah diproses (MappedType atau BaseType dari generated).
// `dstRawType` adalah tipe mentah dari database tujuan.
func (s *SchemaSyncer) areTypesEquivalent(srcTypeForComp, dstRawType string, srcInfo, dstInfo ColumnInfo, log *zap.Logger) bool {
	log.Debug("Comparing types for equivalence",
		zap.String("src_type_for_comparison", srcTypeForComp),
		zap.String("dst_raw_type", dstRawType))

	normSrcCompType := normalizeTypeName(srcTypeForComp) // Tipe dasar dari sumber (setelah mapping/ekstraksi)
	normDstRawType := normalizeTypeName(dstRawType)     // Tipe dasar dari tujuan

	log.Debug("Normalized base types for equivalence check",
		zap.String("norm_src_comp_type", normSrcCompType),
		zap.String("norm_dst_raw_type", normDstRawType))

	if normSrcCompType == normDstRawType { // Tipe dasar sama, periksa modifier
		if isStringType(normSrcCompType) || isBinaryType(normSrcCompType) {
			srcLen := int64(-1); if srcInfo.Length.Valid { srcLen = srcInfo.Length.Int64 } else if isLargeTextOrBlob(normSrcCompType) { srcLen = -2 }
			dstLen := int64(-1); if dstInfo.Length.Valid { dstLen = dstInfo.Length.Int64 } else if isLargeTextOrBlob(normDstRawType) { dstLen = -2 }
			isSrcFixed := (strings.HasPrefix(normSrcCompType, "char") && !strings.HasPrefix(normSrcCompType, "varchar")) ||
				(strings.HasPrefix(normSrcCompType, "binary") && !strings.HasPrefix(normSrcCompType, "varbinary"))
			isDstFixed := (strings.HasPrefix(normDstRawType, "char") && !strings.HasPrefix(normDstRawType, "varchar")) ||
				(strings.HasPrefix(normDstRawType, "binary") && !strings.HasPrefix(normDstRawType, "varbinary"))

			if isSrcFixed != isDstFixed && srcLen == dstLen && srcLen > 0 {
				log.Debug("Type fixed/variable nature mismatch with same length, considered different.", zap.Bool("src_fixed", isSrcFixed), zap.Bool("dst_fixed", isDstFixed), zap.Int64("length", srcLen))
				return false
			}
			if !(srcLen == -2 && dstLen == -2) && srcLen != dstLen {
				log.Debug("Type length mismatch.", zap.Int64("src_len", srcLen), zap.Int64("dst_len", dstLen))
				return false
			}
		}
		if isPrecisionRelevant(normSrcCompType) {
			srcPrec := int64(-1); if srcInfo.Precision.Valid { srcPrec = srcInfo.Precision.Int64 }
			dstPrec := int64(-1); if dstInfo.Precision.Valid { dstPrec = dstInfo.Precision.Int64 }
			isTimeType := strings.Contains(normSrcCompType, "time") || strings.Contains(normSrcCompType, "timestamp")

			if isTimeType {
				if !((srcPrec <= 0 || !srcInfo.Precision.Valid) && (dstPrec <= 0 || !dstInfo.Precision.Valid)) && (srcPrec != dstPrec) {
					log.Debug("Time type precision mismatch.", zap.Int64("src_prec", srcPrec), zap.Bool("src_prec_valid", srcInfo.Precision.Valid), zap.Int64("dst_prec", dstPrec), zap.Bool("dst_prec_valid", dstInfo.Precision.Valid))
					return false
				}
			} else {
				if srcInfo.Precision.Valid != dstInfo.Precision.Valid || (srcInfo.Precision.Valid && dstInfo.Precision.Valid && srcPrec != dstPrec) {
					log.Debug("Decimal/Numeric type precision mismatch or one is not set.", zap.Int64("src_prec", srcPrec), zap.Bool("src_prec_valid", srcInfo.Precision.Valid), zap.Int64("dst_prec", dstPrec), zap.Bool("dst_prec_valid", dstInfo.Precision.Valid))
					return false
				}
			}
		}
		if isScaleRelevant(normSrcCompType) {
			srcScale := int64(0); if srcInfo.Scale.Valid { srcScale = srcInfo.Scale.Int64 }
			dstScale := int64(0); if dstInfo.Scale.Valid { dstScale = dstInfo.Scale.Int64 }
			if (srcInfo.Scale.Valid != dstInfo.Scale.Valid && !(srcScale == 0 && dstScale == 0)) ||
				(srcInfo.Scale.Valid && dstInfo.Scale.Valid && srcScale != dstScale) {
				log.Debug("Decimal/Numeric type scale mismatch or one is explicitly set while other is default 0.",
					zap.Int64("src_scale", srcScale), zap.Bool("src_scale_valid_original", srcInfo.Scale.Valid),
					zap.Int64("dst_scale", dstScale), zap.Bool("dst_scale_valid_original", dstInfo.Scale.Valid))
				return false
			}
		}
		log.Debug("Base types match and relevant attributes (length/precision/scale) appear equivalent.")
		return true
	}

	// Logika ekuivalensi antar dialek
	if (s.srcDialect == "mysql" && (s.dstDialect == "postgres" || s.dstDialect == "sqlite")) ||
		((s.srcDialect == "postgres" || s.srcDialect == "sqlite") && s.dstDialect == "mysql") {
		isSrcEffectivelyBool := normSrcCompType == "bool" || (normSrcCompType == "tinyint" && srcInfo.Length.Valid && srcInfo.Length.Int64 == 1 && s.srcDialect == "mysql")
		isDstEffectivelyBool := normDstRawType == "bool" || (normDstRawType == "tinyint" && dstInfo.Length.Valid && dstInfo.Length.Int64 == 1 && s.dstDialect == "mysql")
		if isSrcEffectivelyBool && isDstEffectivelyBool {
			log.Debug("Equivalent boolean types (e.g., tinyint(1) <=> bool) across dialects found.")
			return true
		}
	}
	if (normSrcCompType == "datetime" && normDstRawType == "timestamp") || (normSrcCompType == "timestamp" && normDstRawType == "datetime") {
		srcPrec := int64(-1); if srcInfo.Precision.Valid { srcPrec = srcInfo.Precision.Int64 }
		dstPrec := int64(-1); if dstInfo.Precision.Valid { dstPrec = dstInfo.Precision.Int64 }
		if ((srcPrec <= 0 || !srcInfo.Precision.Valid) && (dstPrec <= 0 || !dstInfo.Precision.Valid)) || (srcPrec == dstPrec) {
			log.Debug("Equivalent datetime/timestamp types with similar/default precision found.")
			return true
		}
		log.Debug("Types datetime/timestamp differ in precision.", zap.Int64("src_prec", srcPrec), zap.Int64("dst_prec", dstPrec))
		return false
	}
	if (normSrcCompType == "decimal" && normDstRawType == "numeric") || (normSrcCompType == "numeric" && normDstRawType == "decimal") {
		srcPrec := int64(-1); if srcInfo.Precision.Valid { srcPrec = srcInfo.Precision.Int64 }
		dstPrec := int64(-1); if dstInfo.Precision.Valid { dstPrec = dstInfo.Precision.Int64 }
		srcScale := int64(0); if srcInfo.Scale.Valid { srcScale = srcInfo.Scale.Int64 }
		dstScale := int64(0); if dstInfo.Scale.Valid { dstScale = dstInfo.Scale.Int64 }
		precisionMatch := (srcInfo.Precision.Valid == dstInfo.Precision.Valid && srcPrec == dstPrec) || (!srcInfo.Precision.Valid && !dstInfo.Precision.Valid)
		scaleMatch := srcScale == dstScale
		if precisionMatch && scaleMatch {
			log.Debug("Equivalent decimal/numeric types with matching precision/scale (or both default) found.")
			return true
		}
		log.Debug("Types decimal/numeric differ in precision/scale or explicit settings.",
			zap.Int64("src_prec", srcPrec), zap.Bool("src_prec_valid", srcInfo.Precision.Valid), zap.Int64("dst_prec", dstPrec), zap.Bool("dst_prec_valid", dstInfo.Precision.Valid),
			zap.Int64("src_scale", srcScale), zap.Bool("src_scale_valid_orig", srcInfo.Scale.Valid), zap.Int64("dst_scale", dstScale), zap.Bool("dst_scale_valid_orig", dstInfo.Scale.Valid))
		return false
	}

	log.Debug("Types are not equivalent after normalization and all cross-dialect checks.",
		zap.String("norm_src_comp_type_final", normSrcCompType),
		zap.String("norm_dst_raw_type_final", normDstRawType))
	return false
}

// areDefaultsEquivalent membandingkan nilai default.
// Menggunakan versi yang fokus pada nilai efektif setelah normalisasi.
func (s *SchemaSyncer) areDefaultsEquivalent(srcDefRaw, dstDefRaw, typeForDefaultComparison string, log *zap.Logger) bool {
	normSrcDef := normalizeDefaultValue(srcDefRaw, s.srcDialect)
	normDstDef := normalizeDefaultValue(dstDefRaw, s.dstDialect)

	log.Debug("Comparing default values",
		zap.String("src_def_raw", srcDefRaw), zap.String("dst_def_raw", dstDefRaw),
		zap.String("norm_src_def", normSrcDef), zap.String("norm_dst_def", normDstDef),
		zap.String("type_for_comparison_context", typeForDefaultComparison),
	)

	normTypeForDefaultCtx := normalizeTypeName(typeForDefaultComparison)

	// Pemeriksaan awal: Apakah nilai mentahnya secara fundamental berbeda jenisnya?
	// Ini untuk kasus di mana DDL-nya secara fundamental berbeda (angka vs. string angka).
	srcIsQuotedOriginal := (strings.HasPrefix(srcDefRaw, "'") && strings.HasSuffix(srcDefRaw, "'")) ||
		(strings.HasPrefix(srcDefRaw, "\"") && strings.HasSuffix(srcDefRaw, "\""))
	dstIsQuotedOriginal := (strings.HasPrefix(dstDefRaw, "'") && strings.HasSuffix(dstDefRaw, "'")) ||
		(strings.HasPrefix(dstDefRaw, "\"") && strings.HasSuffix(dstDefRaw, "\""))

	_, errSrcRawNumeric := strconv.ParseFloat(srcDefRaw, 64)
	_, errDstRawNumeric := strconv.ParseFloat(dstDefRaw, 64)
	srcIsPotentiallyRawNumeric := errSrcRawNumeric == nil && !srcIsQuotedOriginal
	dstIsPotentiallyRawNumeric := errDstRawNumeric == nil && !dstIsQuotedOriginal

	// Jika satu adalah angka mentah dan yang lain adalah string yang di-quote (bahkan jika isinya angka),
	// anggap berbeda karena DDL aslinya berbeda. Ini penting untuk presisi DDL.
	// Ini berlaku untuk semua tipe kolom target, karena DDL-nya berbeda.
	if (srcIsPotentiallyRawNumeric && dstIsQuotedOriginal) || (dstIsPotentiallyRawNumeric && srcIsQuotedOriginal) {
		if normSrcDef == normDstDef { // Hanya jika nilai ternormalisasinya sama
			log.Debug("Default values have different DDL natures (raw numeric vs. quoted string) but normalize to the same string. Considered different for DDL precision.",
				zap.String("src_raw", srcDefRaw), zap.Bool("src_is_raw_num_check", srcIsPotentiallyRawNumeric), zap.Bool("src_is_quoted_check", srcIsQuotedOriginal),
				zap.String("dst_raw", dstDefRaw), zap.Bool("dst_is_raw_num_check", dstIsPotentiallyRawNumeric), zap.Bool("dst_is_quoted_check", dstIsQuotedOriginal),
				zap.String("norm_val_match", normSrcDef))
			return false // Berbeda karena sifat DDL asli
		}
	}


	if normSrcDef == normDstDef {
		log.Debug("Normalized default values are string-identical, considered equivalent.",
			zap.String("norm_src", normSrcDef), zap.String("norm_dst", normDstDef))
		return true
	}

	if (normSrcDef == "null" && normDstDef == "") || (normSrcDef == "" && normDstDef == "null") {
		log.Debug("One default is explicit 'null' (normalized) and other is empty string (no default set), considered equivalent.")
		return true
	}

	if isNumericType(normTypeForDefaultCtx) {
		if !isKnownDbFunction(normSrcDef) && !isKnownDbFunction(normDstDef) {
			if normTypeForDefaultCtx == "decimal" || normTypeForDefaultCtx == "numeric" {
				srcAPD, _, srcErrAPD := apd.NewFromString(normSrcDef)
				dstAPD, _, dstErrAPD := apd.NewFromString(normDstDef)
				if srcErrAPD == nil && dstErrAPD == nil {
					if srcAPD.Cmp(dstAPD) == 0 {
						log.Debug("Decimal/Numeric default values (from normalized strings) are APD-equivalent.", zap.String("norm_src_for_apd", normSrcDef), zap.String("norm_dst_for_apd", normDstDef))
						return true
					}
					log.Debug("Decimal/Numeric default values (from normalized strings, parsed by APD) differ.", zap.String("norm_src_for_apd", normSrcDef), zap.String("norm_dst_for_apd", normDstDef))
					return false
				}
				log.Debug("Could not parse one or both normalized decimal/numeric defaults as APD.",
					zap.String("norm_src_val", normSrcDef), zap.NamedError("src_apd_err", srcErrAPD),
					zap.String("norm_dst_val", normDstDef), zap.NamedError("dst_apd_err", dstErrAPD))
			}

			srcNumVal, errSrcFloat := strconv.ParseFloat(normSrcDef, 64)
			dstNumVal, errDstFloat := strconv.ParseFloat(normDstDef, 64)

			if errSrcFloat == nil && errDstFloat == nil {
				if srcNumVal == dstNumVal {
					log.Debug("Numeric default values (from normalized strings) are float-equivalent.", zap.Float64("src_num_norm", srcNumVal), zap.Float64("dst_num_norm", dstNumVal))
					return true
				}
				log.Debug("Numeric default values (from normalized strings, parsed as float64) differ.", zap.Float64("src_num_norm", srcNumVal), zap.Float64("dst_num_norm", dstNumVal))
				return false
			}
			if (errSrcFloat == nil && errDstFloat != nil) || (errSrcFloat != nil && errDstFloat == nil) {
				log.Debug("One normalized default is float-parsable, the other is not (and neither are known DB functions or identical strings). Considered different.",
					zap.String("norm_src_for_float", normSrcDef), zap.Error(errSrcFloat),
					zap.String("norm_dst_for_float", normDstDef), zap.Error(errDstFloat))
				return false
			}
		}
	}

	log.Debug("Default values are not equivalent after all checks (fell through to final false).",
		zap.String("final_norm_src_def", normSrcDef), zap.String("final_norm_dst_def", normDstDef))
	return false
}
